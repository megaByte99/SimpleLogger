package it.simple.logger;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.MessageFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ResourceBundle;
import java.lang.System.Logger.Level;

/**
 * <p style="text-align:justify;">
 * The {@code SimpleLogger} is a very simple logger with basic functionality:
 * <ul>
 *    <li>Log of messages displayed on console (Always active);</li>
 *    <li>Log of messages written to a log file (Configurable during the creation of the class).</li>
 * </ul>
 * </p>
 * <br/>
 * The {@code SimpleLogger} is not customizable through a {@code .properties} file, because it use a internal message
 * formatter and the name of the file generated is not customizable either.
 * Is not the purpose of the class.
 * <br/>
 * @version 1.0
 */
public class SimpleLogger {

    /**
     * The private class {@code CoreLogger} represents the core of the main {@link SimpleLogger} class.
     */
    private class CoreLogger implements System.Logger {

        @Override
        public String getName() { return ""; }

        @Override
        public boolean isLoggable(Level level) { return false; }

        @Override
        public void log(Level level, ResourceBundle bundle, String msg, Throwable thrown) { /* ... */ }

        /**
         * Logs a message with resource bundle and an optional list of
         * parameters.
         * <p>
         * If the given resource bundle is non-{@code null},  the {@code format}
         * string is localized using the given resource bundle.
         * Otherwise the {@code format} string is not localized.
         *
         * @param level  the log message level.
         * @param bundle a resource bundle to localize {@code format}; can be
         *               {@code null}.
         * @param format the string message format in {@link
         *               MessageFormat} format, (or a key in the message
         *               catalog if {@code bundle} is not {@code null}); can be {@code null}.
         * @param params an optional list of parameters to the message (may be
         *               none).
         * @throws NullPointerException if {@code level} is {@code null}.
         */
        @Override
        public void log(Level level, ResourceBundle bundle, String format, Object... params) {
            String s_params = "";
            if (params != null && params.length > 0)
                s_params = params[0].toString();


            // Get the line number of where the method was called
            int lineNumber = (s_params.equals(START_LOG)) ? 0 : Thread.currentThread().getStackTrace()[DEPTH_LOG_STACK_TRACE].getLineNumber();

            // Format the message
            String message = String.format(FORMATTED_MESSAGE,
                    LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss"))
                    , level.getName()
                    , (s_params.equals(START_LOG)) ? "SimpleLogger" : loggerName
                    , lineNumber
                    , (format == null) ? "Empty Message" : format
            );

            // Print Message to console
            System.out.print(message);

            // Write to file
            if (writeToFile && !s_params.equals("File Error")) {
                try {
                    Files.writeString(fileLogPath, message, StandardOpenOption.APPEND);
                } catch (IOException e) {
                    this.log(Level.ERROR, null, this.printException(e), new Object[]{"File Error"});
                }
            }
        }

        /**
         * <p style="text-align:justify;">
         * Format the message generated by {@link Exception} by creating a sort of tree view using the {@code '\t' char}
         * with the main message at the beginning and below all the {@link StackTraceElement}
         * </p>
         * @param ex the {@link Exception} that was thrown
         * @return the formatted {@link Exception} message
         */
        public String printException(Exception ex) {
            StringBuilder exceptionMessage = new StringBuilder("Exception " + ex.toString() + " at:\n");

            for (StackTraceElement e : ex.getStackTrace())
                exceptionMessage.append("\t\t").append(e.toString()).append("\n");

            return exceptionMessage.toString();
        }
    }

    // Logger
    private CoreLogger coreLogger;

    /**
     * The structure of log file name: {@code Run_yyyy-MM-dd.log} where the date correspond to today
     */
    private static final String LOG_FILE_NAME           = "Run_%s.log";

    /**
     * The structure of log message.
     */
    private static final String FORMATTED_MESSAGE       = "[%s][%s - %s:%d] %s\n";

    /**
     * The default location of the log directory
     */
    public static final Path DEFAULT_LOG_PATH        = Paths.get(System.getProperty("user.dir") + "/log");

    /**
     * The position within {@link Thread#getStackTrace()} array where the log method call is contained.
     */
    private static final int    DEPTH_LOG_STACK_TRACE   = 4;

    // Variables
    private final String START_LOG = "Start Log";

    // Logger Name
    private String loggerName;

    // Path of file log
    private Path fileLogPath;

    private boolean writeToFile = false;

    /**
     * Empty constructor
     */
    protected SimpleLogger() { /* ... */ }

    /**
     * Create a new instance of {@link SimpleLogger} without File handler.
     *
     * @param loggerName name of the Logger
     * @return instance of {@link SimpleLogger}
     */
    public static SimpleLogger createLogger(String loggerName) {
        return SimpleLogger.createLogger(loggerName, null);
    }

    /**
     * Create a new instance of {@code SimpleLogger}.
     *
     * @param loggerName name of the Logger
     * @param dirLogPath the path to the log directory
     * @return a new SimpleLogger's instance
     */
    public static SimpleLogger createLogger(String loggerName, Path dirLogPath) {
        SimpleLogger instance = new SimpleLogger();

        try {
            instance.init(loggerName, dirLogPath);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        return instance;
    }

    /**
     * Create a new instance of CoreLogger and, if the {@code dirLogPath} is not null,
     * create the directory and the file of log
     *
     * @param loggerName name of the Logger
     * @param dirLogPath the path to the log directory.
     * @throws Exception if the directory or file creation goes wrong.
     */
    private void init(String loggerName, Path dirLogPath) throws Exception {
        this.loggerName = loggerName;
        this.coreLogger = new CoreLogger();

        if (dirLogPath != null) {
            if (Files.notExists(dirLogPath)) Files.createDirectory(dirLogPath);

            String formattedDate = LocalDate.now().format(DateTimeFormatter.ofPattern("dd-MM-yyyy"));
            this.fileLogPath = dirLogPath.resolve(String.format(LOG_FILE_NAME, formattedDate));

            if (Files.notExists(fileLogPath)) Files.createFile(fileLogPath);

            writeToFile = true;
        }
    }

    /**
     * Log a header. It should be used to divide one run of code from another.
     */
    public void printLogHeader() {
        coreLogger.log(Level.INFO, null, String.format(
                        "===================== Start Logging - %s =====================",
                        LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss"))
                ),
                new Object[]{START_LOG}
        );
    }

    /**
     * Print an INFO Log message.
     *
     * @param message The Log message.
     */
    public void info(String message) {
        coreLogger.log(Level.INFO, message);
    }

    /**
     * Print a WARNING Log message.
     *
     * @param message The Log message.
     */
    public void warning(String message) {
        coreLogger.log(Level.WARNING, message);
    }

    /**
     * Print an ERROR Log message.
     *
     * @param message The Log message.
     */
    public void error(String message) {
        coreLogger.log(Level.ERROR, message);
    }

    /**
     * Print a DEBUG Log message.
     *
     * @param message The Log message.
     */
    public void debug(String message) {
        coreLogger.log(Level.DEBUG, message);
    }

    /**
     * Print a TRACE Log message.
     *
     * @param message The Log message.
     */
    public void trace(String message) {
        coreLogger.log(Level.TRACE, message);
    }

    /**
     * Print an Exception.
     * @param e The Exception thrown inside code.
     */
    public void exception(Exception e) {
        coreLogger.printException(e);
    }

}
